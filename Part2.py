##Part 2
'''
First pass - choose 90 more spikes to make a more general sample spike
-threshold? keep paper standards?
-computation time (TBD)
'''

import os, math
os.chdir("/Volumes/KINGSTON/Coding/")

def compute_relation(x, y, n):
    '''(list, list) -> float
    x: current window in the EEG data
    y: list of values generated by Part 1 and modified by Part 2
    n: number of points per window (=len(x)=len(y))
    Return sample correlation value'''
    
    x_avg = sum(x)/float(n)
    y_avg = sum(y)/float(n)
    numerator = 0
    x_denom = 0
    y_denom = 0
    for i in range(n)
        numerator += ((x[i] - x_avg) * (y[i] - y_avg))
        x_denom += ((x[i] - x_avg) * (x[i] - x_avg))
        y_denom += ((y[i] - y_avg) * (y[i] - y_avg))
    denominator = math.sqrt(x_denom * y_denom)
    return numerator/denominator

def first_pass(data_file, index, time_file, sample_spike, target, n, threshold):
    '''(string, int, string, list, list) -> list
    data_file: name of the data file
    index: index of the channel
    time_file: name of the file containing timestamps
    sample_spike: list of values for the sample spike
    target: total number of samples to be incorporated into first pass
    n: number of points per window
    threshold: threshold for first pass
    
    Use
    get_times
    compute_relation
    append_times
    
    Modify sample_spike by averaging target number of spikes
    Return modified sample_spike'''
    
    f = open(data_file)
    first_line = f.readline()
    line = f.readline()    
    list_of_times = get_times(time_file)
    count = len(list_of_times)
    while count < target:
        currtime = float((line.split(","))[0])
        if currtime not in list_of_times:
            window = []
            for n in range(n):
                window.append = float((line.split(","))[index])
            if compute_relation(window, sample_spike) > threshold:
                for i in range(n):
                    sample_spike[i] = ((sample_spike[i] * float(count))\
                    + window[i])/float(count + 1)
                list_of_times.append(currtime)
                append_times(time_file, currtime)
                count += 1
        line = f.readline()
        if line == None: #change if I get a response back
            return sample_spike
    return sample_spike