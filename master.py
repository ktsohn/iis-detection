##MASTER FILE## - EVERYTHING SHOULD BE HERE
'''
Collate everything
-copy functions here as needed
-determine parameters/variables as needed: flexibility!
'''

import os, math
os.chdir("/Volumes/KINGSTON/Coding/")

##Helper functions

def select_channel(data_file, channel):
    '''(str, str) -> int
    data_file: name of the data file
    channel: name of channel
    Return index of channel
    '''
    
    f = open(data_file)
    first_line = f.readline()
    time_and_channels = first_line.split("-Ref,")
    time_and_channels[-1] = time_and_channels[-1].rstrip("-Ref\n")
    for i in range(len(time_and_channels)):
        if time_and_channels[i] == channel:
            return i

def get_times(time_file):
    '''string -> list
    time_file: name of file that contains the timestamps
    Return list of time listed in "time_file", but as one float each'''
    
    list_of_times = []
    f=open(time_file)
    line = f.readline()
    while line != None:
        line = f.readline()
        components = line.split(":")
        time = float((int(components[0]) * 86400) + (int(components[1]) * 3600) + \
        (int(components[2]) * 60) + float(components[3]))
        list_of_times.append(time)
    return list_of_times

def select_sample(data_file, index, start_time, n):
    '''(str, str, float) -> list of floats
    data_file: name of the data file
    index: index of channel
    start_time: the value for the beginning of the window
    n: number of points per window (window * frequency)
    
    Return values for channel and time frame specified
    Include start_time and end 300ms (75 samples) later'''
    
    f = open(data_file)
    first_line = f.readline()
    line = f.readline()
    currtime = float((line.split(","))[0])
    if currtime > start_time:
        start_time += 86400
    while currtime != start_time:
        line = f.readline()
        currtime = float((line.split(","))[0])
    window = []
    for i in range(n):
        window.append = float((line.split(","))[index])
        line = f.readline()
    
    return window
    
def make_sample_spike(data_file, index, time_file, sample_number, n):
    '''(string, string, int) -> (list)
    data_file: name of the data file
    index: index of channel
    time_file: name of the file that contains the timestamps
    sample_number: number of hand-picked samples to be averaged
    n: number of points per window (window * frequency)
    
    Use
    get_times
    select_sample
    
    Make dictionary of sample_number spikes
    Return list containing an average'''
    
    spikes = {}
    sample_spike = []
    time_list = get_times(time_file)
    for time in time_list:
        spikes[time] = select_sample(data_file, index, time)
    for j in range(n):
        avg = 0
        for keys in spikes:
            avg += spikes[keys][j]
        sample_spike[j] = avg/float(sample_number)
    return sample_spike

def compute_relation(x, y, n):
    '''(list, list) -> float
    x: current window in the EEG data
    y: list of values generated by Part 1 and modified by Part 2
    n: number of points per window (=len(x)=len(y))
    Return sample correlation value'''
    
    x_avg = sum(x)/float(n)
    y_avg = sum(y)/float(n)
    numerator = 0
    x_denom = 0
    y_denom = 0
    for i in range(n)
        numerator += ((x[i] - x_avg) * (y[i] - y_avg))
        x_denom += ((x[i] - x_avg) * (x[i] - x_avg))
        y_denom += ((y[i] - y_avg) * (y[i] - y_avg))
    denominator = math.sqrt(x_denom * y_denom)
    return numerator/denominator

##Master function
def detect_iis(data_file, channel, frequency, window, sample1, threshold1, sample2, threshold2, time_file):

    '''
    (string, string, int, float, int, float, int, float, string) -> int
    data_file: name of .csv file
    channel: name of channel being examined
    frequency: frequency of recording - taken from info.txt for each .csv file
    window: length of spike
    sample1: number of handpicked samples
    threshold1: threshold for first pass
    sample2: total number of samples incorporated into first pass
    threshold2: threshold for detection
    time_file: name of .txt file that contains spike times - modified
    
    Use
    select_channel
    
    
    Return number of IIS found, including those incorporated into first pass
    '''
    
    n = int(window * frequency)
    index = select_channel(data_file, channel)
    #initializing conditions
    spike_1 = make_sample_spike(data_file, index, time_file, sample1, n)
    #template spike made from hand-picked windows
    